# -*- coding: utf-8 -*-
"""ConvolutionalNeuralNetwork.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1r_i3Ufq6vnOITBD_bh3kz82KXrobPLRT

Training a Convolutional Neural Network to Enhance Vision. 
Keras inbuilt MNIST dataset will be used to train the model

An array(3x3 or 5x5) is passed over the image. By changing the underlying pixels based on the formula within that matrix, you can do things like edge detection.

Using convolution we highlight the features in the image that distinguish one item from the other making the information that is required much less. This result in the information that goes in to the dense layer be more focused and more accurate.
"""

import tensorflow as tf

"""The Callback function will stop training once the accuracy hits 99.8%"""

class myCallback(tf.keras.callbacks.Callback):
  def on_epoch_end(self, epoch, logs={}):
    if(logs.get('accuracy') >= 0.998):
      print('\nReached 99.8% accuracy so cancelling training!')
      self.model.stop_training = True
    
callbacks = myCallback()

mnist = tf.keras.datasets.mnist
(training_images, training_labels), (test_images, test_labels) = mnist.load_data()

"""Dataset should be reshaped in order to fit the convolutional layer 

The first convolution expects a single tensor containing everything, so instead of 60,000 28x28x1 items in a list, we make a single 4D list that is 60000x28x28x1
"""

training_images = training_images.reshape(60000, 28, 28, 1)
training_images = training_images/255.0
test_images = test_images.reshape(10000, 28, 28, 1)
test_images = test_images/255.0

"""**Modal Definition**

Parameters,

1.   The number of convolutions to generate. Purely arbitrary, but good to start with something in the order of 32
2.   The size of the Convolution, in this case a 3x3 grid
3.   The activation function to use -- in this case we'll use relu, which is the equivalent of returning x when x>0, else returning 0 
4.   In the first layer, the shape of the input data

Convolution is followed with a MaxPooling layer which is then designed to compress the image, while maintaining the content of the features that were highlighted by the convlution. By specifying (2,2) for the MaxPooling, the effect is to quarter the size of the image. The idea is that it creates a 2x2 array of pixels, and picks the biggest one, thus turning 4 pixels into 1. It repeats this across the image, and in so doing halves the number of horizontal, and halves the number of vertical pixels, effectively reducing the image by 25%.

You can call model.summary() to see the size and shape of the network, and you'll notice that after every MaxPooling layer, the image size is reduced in this way.
"""

model = tf.keras.models.Sequential([
    tf.keras.layers.Conv2D(64, (3,3), activation='relu', input_shape=(28, 28, 1)),
    tf.keras.layers.MaxPooling2D(2, 2),
    tf.keras.layers.Flatten(),
    tf.keras.layers.Dense(128, activation='relu'),
    tf.keras.layers.Dense(10, activation='softmax')
])

model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])
model.summary()
model.fit(training_images, training_labels, epochs = 20, callbacks=[callbacks])